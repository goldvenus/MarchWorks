{"version":3,"file":"static/webpack/static\\development\\pages\\about.js.da5341f8030c7f443f6a.hot-update.js","sources":["webpack:///./classes/ImageEditor.js"],"sourcesContent":["class ImageEditor {\r\n\tconstructor(canvas, src, maxWidth, maxHeight, filter='grayscale', args) {\r\n\t\tthis.maxWidth = maxWidth\r\n\t\tthis.maxHeight = maxHeight\r\n\t\tthis.src = src\r\n\t\tthis.canvas = canvas\r\n\t\tthis.ctx = this.canvas.getContext('2d')\r\n\t\tthis.data = []\r\n\t\tthis.filter = filter\r\n\t\tthis.args = typeof args === 'string' ? args.toLowerCase() : ((typeof args === 'object' || typeof args === 'function') ? false : args)\r\n\t\tthis.originalData = null\r\n\t\tthis.load()\r\n\r\n\t\tthis.drawOver = this.drawOver.bind(this)\r\n\t}\r\n\tasync load(){\r\n\t\tthis.img = await this.addImageProcess(this.src)\r\n\t\tthis.onload()\r\n\t}\r\n\taddImageProcess(src){\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t    let img = new Image()\r\n\t    img.onload = () => resolve(img)\r\n\t    img.onerror = reject\r\n\t    img.src = src\r\n  \t\t})\r\n\t}\r\n\tonload(maxw=0 , maxh=0){\r\n\t\tif(maxh !== 0 && maxw !== 0){\r\n\t\t\tthis.maxWidth = maxw;\r\n\t\t\tthis.maxHeight = maxh;\r\n\t\t}\r\n\t\tif(this.img.naturalWidth   > this.maxWidth){\r\n\t\t\tthis.img.height = this.img.height*this.maxWidth/this.img.width\r\n\t\t\tthis.img.width  = this.maxWidth\r\n\t\t}\r\n\t\tif(this.img.height  > this.maxHeight){\r\n\t\t\tthis.img.width  = this.img.width*this.maxHeight/this.img.height\t\r\n\t\t\tthis.img.height = this.maxHeight\r\n\t\t}\r\n\r\n\t\tif(this.filter === 'sobel'){\r\n\t\t\tthis.data = this.sobel()\r\n\t\t\tthis.ctx.putImageData(this.data, 0, 0);\r\n\t\t}else{\r\n\t\t\tvar st = ['reverseRGB']\r\n\t\t\tvar args = st.includes(this.filter) ? (['rg', 'gr', 'rb', 'br', 'bg', 'gb'].includes(this.args) ? this.args : 'rb') : 100\r\n\t\t\tthis.data = this.filterImage(this.filter, args)\r\n\t\t\tthis.ctx.putImageData(this.data, 0, 0);\r\n\t\t}\r\n\t\tthis.drawOver()\r\n\t}\r\n\tgetPixels() {\r\n\t\tthis.canvas.width = this.img.width;\r\n\t\tthis.canvas.height = this.img.height;\r\n\t\tthis.ctx.drawImage(this.img, 0, 0, this.canvas.width, this.canvas.height);\r\n\t\tthis.originalData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n\t\treturn this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n\t}\r\n\tfilterImage(filter, var_args) {\r\n\t  \tvar args = [this.getPixels()];\r\n\t  \tfor (var i=1; i<arguments.length; i++) {\r\n\t    \targs.push(arguments[i]);\r\n\t  \t}\r\n\t  \treturn this[filter].apply(null, args);\r\n\t}\r\n\tgrayscale(pixels, args) {\r\n\t  \tvar d = pixels.data;\r\n\t  \tfor (var i=0; i<d.length; i+=4) {\r\n\t\t    var r = d[i];\r\n\t\t    var g = d[i+1];\r\n\t\t    var b = d[i+2];\r\n\t\t    var v = 0.2126*r + 0.7152*g + 0.0722*b;\r\n\t\t    d[i] = d[i+1] = d[i+2] = v\r\n\t  \t}\r\n\t  \treturn pixels;\r\n\t}\r\n\tdrawOver(){\r\n\t\tconst num = 1\r\n\t\tthis.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\r\n\t\tthis.ctx.putImageData(this.data, 0, 0);\r\n\t\tfor (var i = 0; i < num; i++) {\r\n\t\t\tthis.ctx.beginPath();\r\n\t\t\tvar pos = {x: this.canvas.width*Math.random(), y: this.canvas.height*Math.random()}\r\n\t\t\tthis.ctx.moveTo(pos.x, pos.y);\r\n\t\t\tthis.ctx.lineTo(pos.x + Math.random()*(50 - 10) + 10, pos.y);\r\n\t\t\tthis.ctx.stroke();\r\n\t\t}\r\n\t\trequestAnimationFrame(this.drawOver)\r\n\t}\r\n\tthreshold(pixels, threshold=100) {\r\n\t\tvar d = pixels.data;\r\n\t\tfor (var i=0; i<d.length; i+=4) {\r\n\t\t    var r = d[i];\r\n\t\t    var g = d[i+1];\r\n\t\t    var b = d[i+2];\r\n\t\t    var v = (0.2126*r + 0.7152*g + 0.0722*b >= threshold) ? 255 : 0;\r\n\t\t    d[i] = d[i+1] = d[i+2] = v\r\n\t\t}\r\n  \t\treturn pixels;\r\n\t}\r\n\treverse(pixels, threshold) {\r\n\t\tvar d = pixels.data;\r\n\t\tfor (var i=0; i<d.length; i+=4) {\r\n\t\t    d[i] = 255 - d[i];\r\n\t\t    d[i+1] = 255 - d[i+1];\r\n\t\t    d[i+2] = 255 - d[i+2];\r\n\t\t}\r\n  \t\treturn pixels;\r\n\t}\r\n\treverseRGB(pixels, rgb='rb') {\r\n\t\tvar d = pixels.data;\r\n\t\tif(rgb === 'rg' || rgb === 'gr'){\r\n\t\t\tfor (var i=0; i<d.length; i+=4) {\r\n\t\t\t\tvar e = d[i];\r\n\t\t\t\td[i] = d[i+1];\r\n\t\t    \td[i+1] = e;\r\n\t\t\t}\r\n\t\t}else if(rgb === 'rb' || rgb === 'br'){\r\n\t\t\tfor (var i=0; i<d.length; i+=4) {\r\n\t\t\t\tvar e = d[i];\r\n\t\t\t    d[i] = d[i+2];\r\n\t\t\t    d[i+2] = e;\r\n\t\t\t}\t\r\n\t\t}else if(rgb === 'gb' || rgb === 'bg'){\r\n\t\t\tfor (var i=0; i<d.length; i+=4) {\r\n\t\t\t\tvar e = d[i+1];\r\n\t\t\t    d[i+1] = d[i+2];\r\n\t\t\t    d[i+2] = e;\r\n\t\t\t}\t\r\n\t\t}\r\n  \t\treturn pixels;\r\n\t}\r\n\tsobel(){\r\n\t\tvar grayscale = this.filterImage(\"reverseRGB\", 'rb');\r\n\t\t// Note that ImageData values are clamped between 0 and 255, so we need\r\n\t\t// to use a Float32Array for the gradient values because they\r\n\t\t// range between -255 and 255.\r\n\r\n\t\tvar vertical = this.convolute(grayscale,\r\n\t\t  [ 0  ,   0  ,   0,\r\n\t\t    0  ,   Math.random()+1  ,   0,\r\n\t\t    0  ,   0  ,   0 ]);\r\n\t\tvar horizontal = this.convolute(grayscale,\r\n\t\t  [ 0  ,   0  ,   0,\r\n\t\t    0  ,   Math.random()+1  ,   0,\r\n\t\t    0  ,   0  ,   0 ]);\r\n\t\tvar final_image = this.ctx.createImageData(vertical.width, vertical.height);\r\n\t\tfor (var i=0; i<final_image.data.length; i+=4) {\r\n\t\t  // make the vertical gradient red\r\n\t\t  var v = Math.abs(vertical.data[i]);\r\n\t\t  final_image.data[i] = v;\r\n\t\t  // make the horizontal gradient green\r\n\t\t  var h = Math.abs(horizontal.data[i]);\r\n\t\t  final_image.data[i+1] = h;\r\n\t\t  // and mix in some blue for aesthetics\r\n\t\t  final_image.data[i+2] = (v+h)/2;\r\n\t\t  final_image.data[i+3] = 255; // opaque alpha\r\n\t\t}\r\n\t\treturn final_image\r\n\t}\r\n\r\n\tconvolute(pixels, weights, opaque) {\r\n\t\tvar side = Math.round(Math.sqrt(weights.length));\r\n\t\tvar halfSide = Math.floor(side/2);\r\n\t\tvar src = pixels.data;\r\n\t\tvar sw = pixels.width;\r\n\t\tvar sh = pixels.height;\r\n\t\t// pad output by the convolution matrix\r\n\t\tvar w = sw;\r\n\t\tvar h = sh;\r\n\t\tvar output = this.ctx.createImageData(w, h);\r\n\t\tvar dst = output.data;\r\n\t\t// go through the destination image pixels\r\n\t\tvar alphaFac = opaque ? 1 : 0;\r\n\t\tfor (var y=0; y<h; y++) {\r\n\t\t\tfor (var x=0; x<w; x++) {\r\n\t\t\t  var sy = y;\r\n\t\t\t  var sx = x;\r\n\t\t\t  var dstOff = (y*w+x)*4;\r\n\t\t\t  // calculate the weighed sum of the source image pixels that\r\n\t\t\t  // fall under the convolution matrix\r\n\t\t\t  var r=0, g=0, b=0, a=0;\r\n\t\t\t  for (var cy=0; cy<side; cy++) {\r\n\t\t\t    for (var cx=0; cx<side; cx++) {\r\n\t\t\t      var scy = sy + cy - halfSide;\r\n\t\t\t      var scx = sx + cx - halfSide;\r\n\t\t\t      if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {\r\n\t\t\t        var srcOff = (scy*sw+scx)*4;\r\n\t\t\t        var wt = weights[cy*side+cx];\r\n\t\t\t        r += src[srcOff] * wt;\r\n\t\t\t        g += src[srcOff+1] * wt;\r\n\t\t\t        b += src[srcOff+2] * wt;\r\n\t\t\t        a += src[srcOff+3] * wt;\r\n\t\t\t      }\r\n\t\t\t    }\r\n\t\t\t  }\r\n\t\t\t  dst[dstOff] = r;\r\n\t\t\t  dst[dstOff+1] = g;\r\n\t\t\t  dst[dstOff+2] = b;\r\n\t\t\t  dst[dstOff+3] = a + alphaFac*(255-a);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n}\r\n\r\nexport default ImageEditor;"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AACA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;AACA;AACA;;AADA;AACA;AACA;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;AAGA;;;;A","sourceRoot":""}